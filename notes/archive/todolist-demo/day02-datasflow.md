# Vue Todo 项目 · Day 2：响应式数据流与组件职责总结

本文基于一个 TodoList 示例项目，总结了 Vue 3 中 **响应式数据流、组件分工以及 composable 的职责划分**，帮助我从“会写代码”走向“理解框架设计”。

---

## 一、整体架构概览

Todo 项目采用了三层结构：

- **composable（useTodos）**：状态与业务逻辑
- **父组件（TodoList.vue）**：状态拥有者 + 业务调度者
- **子组件（TodoItem.vue）**：纯展示 + 事件通知

整体遵循 **单向数据流**：

> 用户操作 → 子组件 emit → 父组件处理 → composable 修改状态 → Vue 响应式更新视图

---

## 二、composable（useTodos）的职责

- 存放**可复用的数据源（响应式状态）**
- 定义**操作这些数据的业务逻辑函数**
- 与具体 UI、DOM、组件结构无关
- 通过 `export function useXXX()` 的形式向外暴露状态和方法

> composable 不关心页面如何渲染，只关心：
> - 数据是什么
> - 数据如何变化

---

## 三、组件职责划分（components）

### 1️⃣ 子组件：TodoItem.vue

- 只负责**视图展示**
- 不直接修改状态
- 通过 `props` 接收父组件传入的数据
- 通过 `emits` 向父组件发送用户操作的**意图**
- 在当前设计中，template 中只绑定事件名，参数在事件处理函数内部统一处理

子组件的核心原则是：

> **不拥有状态，只表达发生了什么**

---

### 2️⃣ 父组件：TodoList.vue

- 作为**状态拥有者和业务调度者**
- 从 composable 中获取：
    - 响应式数据
    - 修改数据的业务方法
- 在 template 中组织页面结构
- 通过 `props` 将数据传入子组件
- 接收子组件 emit 的事件，并调用 composable 中的方法执行业务逻辑

---

## 四、单向数据流与响应式更新机制

项目整体遵循 Vue 的单向数据流：

1. 用户在子组件中触发操作
2. 子组件通过 `emit` 发送事件给父组件
3. 父组件接收事件并调用 composable 中的方法修改状态
4. Vue 响应式系统自动追踪依赖
5. 状态变化后，相关组件、模板和计算属性自动更新

整个过程中 **不需要手动操作 DOM**。

---

## 五、Todo 功能的增删改实现

Todo 数据的所有修改操作都集中在 composable 中完成：

- 新增 Todo：`addRecord`
- 更新 Todo 文本：`updateRecordText`
- 删除 Todo：`removeRecord`

这种设计使得：

- 数据修改逻辑集中
- 组件职责清晰
- 更易维护和扩展

---

## 六、关于 composable 的理解总结

- composable 负责**数据源和业务逻辑**
- 组件负责**视图渲染和交互**
- 状态变化规则与 UI 解耦
- composable 不关心组件层级、DOM 事件或页面布局

> composable 是连接 Vue 响应式系统与业务逻辑的“中间层”。

---

## 七、总结

通过这个 Todo 项目，我逐步理解了：

- Vue 为什么要强调单向数据流
- 为什么子组件不应该直接修改状态
- composable 在实际项目中的边界和价值
- 如何从“写能跑的代码”过渡到“设计可维护的组件结构”

这套思路同样适用于更复杂的业务场景。

---
## 延伸思考：为什么不用 Vuex / Pinia，而选择 composable？

在这个 Todo 项目中，我没有使用 Vuex 或 Pinia 作为状态管理方案，而是选择了 **composable（useTodos）**。  
这个选择并不是“逃避状态管理”，而是基于**项目规模、复杂度和职责边界**做出的理性判断。

---

### 1️⃣ Vuex / Pinia 解决的是什么问题？

Vuex / Pinia 主要用于解决以下场景：

- 多个页面 / 多个模块 **共享同一份状态**
- 状态需要在应用生命周期内 **长期存在**
- 状态修改需要统一约束（如 action / mutation）
- 项目规模较大，组件层级复杂

换句话说，它们解决的是：

> **“全局状态如何被安全、可预测地管理”**

---

### 2️⃣ 当前 Todo 项目的实际需求

在当前项目中：

- Todo 数据只在 Todo 页面中使用
- 状态不会被多个页面同时依赖
- 业务逻辑简单，生命周期清晰
- 不存在跨模块、跨页面的复杂共享

也就是说，这是一个**典型的“局部状态 + 页面级业务”场景**。

---

### 3️⃣ composable 更适合当前阶段的原因

使用 composable（`useTodos`）的优势在于：

- **轻量**：不需要额外配置 store、模块或插件
- **低心智负担**：状态和操作逻辑天然写在一起
- **可复用**：同一个 composable 可以被多个组件调用
- **符合 Composition API 思维**：逻辑即函数，而不是“特殊语法的容器”

在这个 Todo 项目中，composable 已经完整地承担了：

- 数据源（todos）
- 数据操作逻辑（add / update / remove）
- 与视图解耦的业务规则

这正是 composable 最擅长的使用场景。

---

### 4️⃣ composable ≠ Pinia 的替代品

需要明确的是：

> **composable 并不是 Vuex / Pinia 的替代品，而是不同层级的工具。**

一个常见、健康的演进路径是：

- **小项目 / 页面级状态** → composable
- **中大型项目 / 跨页面状态** → Pinia
- **Pinia 内部依然大量使用 composable 抽离逻辑**

也就是说，二者并不是对立关系，而是**协作关系**。

---

### 5️⃣ 这种选择体现的不是“会不会用”，而是“什么时候用”

在这个项目中选择 composable，而不是 Vuex / Pinia，体现的是：

- 对项目复杂度的判断
- 对状态作用域的划分
- 对工具使用边界的理解

> 能够在“应该简单”的地方保持简单，本身就是一种工程能力。

---

### 6️⃣ 如果将来项目变复杂，会如何演进？

如果未来出现以下情况：

- Todo 状态需要在多个页面共享
- 出现用户系统、权限、配置等全局状态
- 状态逻辑显著增长

那么可以非常自然地：

- 将 `useTodos` 的逻辑迁移到 Pinia store 中
- 保留 composable 作为逻辑拆分单元
- 不需要推翻现有组件设计

当前的架构为这种演进 **预留了空间**。

---

### 小结

在这个 Todo 项目中：

- 使用 composable，是对当前需求最合适的选择
- 不使用 Vuex / Pinia，并不代表不会用
- 而是基于场景、规模和复杂度做出的判断

> 工具本身没有对错，**合适才是最重要的。**

